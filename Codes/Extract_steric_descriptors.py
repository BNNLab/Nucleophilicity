# This code takes the Li-nucleophiles structure (in .xyz files), which is manually curated by adding a Li atom on the nucleophilic site of the nucleophile, as input and return a file with three columns: 
# ||The Molecule's ID||Tolman Cone angle||The Max angle|| with their unit as the degree (no unit written)
# Import data structure package: pandas, import mathematical calculation packages: numpy and math import system tool: os and import regular expression: re
import pandas as pd
import numpy as np
import math
import os
import re
# In order to manually curate the Li-Nu structure, the bond length between the Li atom and the atom on the nucleophilic site is assigned as the dictionary. Those data are averaged from the search result of the ConQuest and Mercury software
coor_radii = {'H': 2.3900,
              'B': 2.3930, 'C': 2.2570, 'N': 2.0790, 'O': 1.991, 'F': 1.9900,
              'P': 2.3109, 'S': 2.4990, 'Cl': 2.3860,
              'Br': 2.5490,
              }
# In the Tolman Cone angle calculation, the atom radius is important to facilitate following calculation. Atomic vdW radius is assigned in the dictionary where the unit is Ang.
# cite and modified from wSterimol codes
# original data from paper: Bondi, A. J. Phys. Chem. 1964, 68, 441-452; hydrogen is from Rowland, R. S.; Taylor, R. J. Phys. Chem. 1996, 100, 7384-7391
radii = {'H': 1.09,
         'B': 1.92, 'C': 1.70, 'N': 1.55, 'O': 1.52, 'F': 1.47,
         'Si': 2.10, 'P': 1.80, 'S': 1.80, 'Cl': 1.75,
         'Ge': 2.11, 'Pb': 1.63, 'Br': 1.85,
         'Sn': 2.17, 'Hg': 1.55, 'I': 1.98
         }
# define a tool to extract all the file path under the folder of Li-Nu.xyz files
def get_file_path(folder):
    path_list = []
    file_name_list = []
    walk_object = os.walk(folder)
    for i in walk_object:
        file_name_list = i[2]
    for n in file_name_list:
        file_path = folder + '\\' + n
        path_list.append(file_path)
    return path_list
# define a tool to extract atoms and its specific coordinate from the Li-Nu.xyz file and store them into a dictionary to store the element type and which atom's (x, y, z) coordinate as a np.array type
def get_xyz(file_path):
    dict = {'Atom': [],
            'XYZ': []}
    with open(file_path) as f:
        lines = f.readlines()
        for item, line in enumerate(lines):
            if item <= 1:
                continue
            part = line.split()
            dict['Atom'].append(part[0].strip())
            dict['XYZ'].append(np.array([float(part[1]), float(part[2]), float(part[3].strip())]))
    return dict
# calculate the vector between two coordinates with respect to equation 8.5.1:5
def get_vec(pos1, pos2):
    # vector = (xB, yB, zB).T - (xA, yA, zA).T
    vector = np.subtract(pos2, pos1)  
    # vector in definition of end point position minus by start point position
    return vector
# calculate the angle between two vectors with respect to equation 8.5.1:7
def get_angle(v1, v2):
    # calculate the longth of the vector
    # length = (x^2 + y^2 + z^2)^0.5
    Lv1 = np.linalg.norm(v1)
    Lv2 = np.linalg.norm(v2)
    # calculate the cos(angle)
    # cos_angle = dot_product(vector1, vector2)/(length_vector1 * length_vector2)
    cos_angle = v1.dot(v2) / (Lv1 * Lv2)
    # calculate the reverse cosine of the cos_angle which unit is in arc
    angle1 = np.arccos(cos_angle)
    # transfer the angle's degree of arc into degree
    angle2 = angle1 * 360 / (2 * np.pi)
    return float(angle2)
# define a tool to calculate the alpha angle, which is the sum of alpha_i1 and alpha_i2 in the figure 42
# A is the lithium atom coordinate. B is the coordinate atom of the ligand.
# C is the coordinate of atom in the bulk. D is dot that the tangent line from A intercept on the vdW sphere C (originated at C, radius is r)
# A, B, C are dots showing as graph, r is the vdW radius of the atom
def get_angle_alpha(A, B, C, r):
    # vab means the vector starts form dot A points to B (this pattern is kept)
    vab = get_vec(A, B)
    vac = get_vec(A, C)
    # calculate the alpha1 angle
    alpha1 = get_angle(vab, vac)
    # calculate the length of vector AC
    Lvac = np.linalg.norm(vac)
    # sin(alpha2) = DC/AC, the reverse sine is done and the alpha2 angle is transferred to degree
    sin_alpha2 = r / Lvac
    alpha2_arc = np.arcsin(sin_alpha2)
    alpha2 = alpha2_arc * 360 / (2 * np.pi)
    # the alpha angle is the sum of alpha1 and alpha2
    alpha_angle = alpha1 + alpha2
    return float(alpha_angle)
# define a tool to put the three max half angles far away enough to simulate the cone shape
# the smallest and maximum tetrahedral angle is generated by ConQuest and Mercury
# min: 46.055, mean: 109.140, max: 162.247, stdev: 10.654
# try min = 46, 60, 85 to see if the TCA > 180 is fixed
def _3d_filter(a_dict, the_B):
    # initialise the list of the alpha angle which is defined as alpha_i1 + alpha_i2 shown in the figure 42
    alpha_list = []
    # find the number of alpha angles
    iter_length = len(a_dict['alpha_angle'])
    # read the dictionary into a pd.Dataframe
    adf = pd.DataFrame(a_dict)
    # further resort of the Dataframe
    aadf = adf.sort_values('alpha_angle', ascending=False).reset_index().drop(columns=['index'])
    # save the biggest alpha angle to the first place of alpha_list and also record the atom C coordinate
    alpha_list.append(aadf.iloc[0, 0])
    the_C = aadf.iloc[0, 1]
    # calculate the vector BC
    vbc = get_vec(the_B, the_C)
    # iterate all alpha angle in the list
    for i in range(iter_length):
        # the biggest one is picked before the loop
        if i == 0:
            continue
        # extract the coordinate of C' for the given alpha angle
        C_prime = aadf.iloc[i, 1]
        # calculate the vector BC'
        vbcprime = get_vec(the_B, C_prime)
        # calculate the aplha_x which represents the alpha angle needed to be confirmed
        alpha_x = get_angle(vbc, vbcprime)
        # the third alpha angle should meet the following condition
        if len(alpha_list) == 2 and 85. <= alpha_x <= 162.247:
            # C'' is the coordinate of the C' coordinate of the second alpha angle
            C_primeprime = aadf.iloc[i_C_prime, 1]
            # calculate the vecotor BC''
            vbcprimeprime = get_vec(the_B, C_primeprime)
            # calculate the angle CBC''
            angle_CBCpp = get_angle(vbc, vbcprimeprime)
            # calculate the angle C'BC''
            angle_CpBCpp = get_angle(vbcprime, vbcprimeprime)
            # if following condition is satisfied, the alpha_x is accepted to be the third alpha angle
            if 85. <= angle_CBCpp <= 162.247 and 85. <= angle_CpBCpp <= 162.247:
                alpha_list.append(alpha_x)
        # the second alpha angle should meet the following condition
        if len(alpha_list) == 1 and 85. <= alpha_x <= 162.247:
            alpha_list.append(alpha_x)
            # record the position of the C' coordinate for the second alpha angle
            i_C_prime = i
        # when three biggest alpha angle with desired distance are extracted,
        end the loop immediately to save computation time
        if len(alpha_list) == 3:
            break
    return alpha_list


# define a tool to extract keys in the dictionary
def get_key(dict, value):
    return [k for k, v in dict.items() if (v == value).all() == True][0]


# define a tool to extract Tolman Cone angle
def get_Tolman_CA(alpha_dict, the_B):
    # calculate the Tolman Cone angle by the strict definition when alpha angles' number equal or small than 3
    if 1 <= len(alpha_dict['alpha_angle']) <= 3:
        tca = sum(alpha_dict['alpha_angle']) * 2 / 3
    # calculate the Tolman Cone angle with selection of 3D filter to when there are more than 3 alpha angles
    elif len(alpha_dict['alpha_angle']) > 3:
        filter_list = _3d_filter(alpha_dict, the_B)
        tca = sum(filter_list) * 2 / 3
    # in case if no Tolman Cone angle is computed, use this to alert
    else:
        tca = 0
        print('Error')
    return tca


# define a tool to extract N_BAD which is called the single largest alpha angle
def get_Tolman_CA_MAX(alpha_list):
    # iterate the alpha_list and filter out any invalid number, such as nan
    for i in alpha_list['alpha_angle']:
        if math.isnan(i) is True:
            # make sure any nan value is set to float 0
            alpha_list['alpha_angle'][alpha_list['alpha_angle'].index(i)] = 0.
    # try to extract the max alpha angle, except there is any type will cause ValueError
    try:
        tca = max(alpha_list['alpha_angle'])
    except ValueError:
        tca = 0.
    return tca


# define a model to automatically calculate the N_TCA and N_BAD using tools defined above
def execute_model(file_folder):
    # initialise the dictionary to store results
    # ||molecules' id||N_TCA||N_BAD||
    TCA_dict = {'Molecule': [],
                'Tolman_Cone_Angle': [],
                'Max_Angle': []}
    # iterate all Li-Nu structures
    for i in get_file_path(file_folder):
        # extract the molecule id of the Li-Nu structure
        xyz_dict = get_xyz(i)
        mol_name = re.findall('manual_Li_xyz\\\\(.+).xyz', i)[0]
        # exam Li cation exists in xyz files
        if xyz_dict['Atom'].count('Li') != 1:
            print('Wrong in XYZ:', re.findall('manual_Li_xyz\\\\(.+).xyz', i)[0])
            continue
        # initiate for every molecules, initialise three indicator for creating the triangle
        # B_type, C_type suggests the existance of atom of nucleophilic site and any other atom rather than the atom of nucleophilic site
        C_type = False
        B_type = False
        # initialise the alpha angle dictionary for every Li-Nu structure
        alpha_dict = {'alpha_angle': [], 'C_xyz': []}
        # get Li position
        A = xyz_dict['XYZ'][xyz_dict['Atom'].index('Li')]
        # find coordination element B and exam if there is C
        for num in range(len(xyz_dict['Atom'])):
            if xyz_dict['Atom'][num] == 'Li':
                continue
            # search the atom type
            element = xyz_dict['XYZ'][num]
            # calculate the length of A and the pseudo B
            vApseudoB = get_vec(A, element)
            LvApseudoB = np.linalg.norm(vApseudoB)
            # While the bond length of A to pseudo B match the records of Li to the atom of pseudo B, the pseudo B is set to be the nucleophlic site B
            if round(LvApseudoB, 4) in coor_radii.values() and xyz_dict['Atom'][num] == get_key(coor_radii,
                                                                                                round(LvApseudoB, 4)):
                B_type = True
                B = element
                continue
            # If the element is not Li or coordination atom, then it will be a C atom
            C_type = True

        # when structure is wrong and need manually corrected
        if B_type == False:
            print(mol_name)
            continue

        # the structure is the case of Figure 42
        if B_type == True and C_type == True:
            for j in range(len(xyz_dict['Atom'])):
                # avoid Li and coordinate atom being labeled as C or D
                if xyz_dict['Atom'][j] == 'Li':
                    continue
                # calculate the distance between A and the atom waiting for pending
                element = xyz_dict['XYZ'][j]
                vApseudoB = get_vec(A, element)
                LvApseudoB = np.linalg.norm(vApseudoB)
                # ignore atom with the same element type and radius as B
                if (element == B).all() == True:
                    continue
                # ignore candidate atom with more than 7 Ang of distance
                if LvApseudoB > 7.:  # set the cut-off
                    continue
                # when the atom is not match any atom at the nucleophilic site B, then it can be set as C
                C = xyz_dict['XYZ'][j]
                # when valid atom C is obtained, record the alpha angle and the coordinate of C
                r = radii[xyz_dict['Atom'][j]]
                alpha_dict['alpha_angle'].append(get_angle_alpha(A, B, C, r))
                alpha_dict['C_xyz'].append(C)

        # the structure is the case of Figure 41 where there is no third atom
        if B_type == True and C_type == False:
            Lvab = np.linalg.norm(get_vec(A, B))
            r = radii[xyz_dict['Atom'][xyz_dict['XYZ'].index(B)]]
            sin_angle = r / Lvab
            t_c_a_arc = np.arcsin(sin_angle)
            t_c_a = (2 / 3) * t_c_a_arc * 360 / (2 * np.pi)
            # store molecule id and calculated cone angle
            TCA_dict['Molecule'].append(mol_name)
            TCA_dict['Tolman_Cone_Angle'].append(t_c_a)
            TCA_dict['Max_Angle'].append(t_c_a)
            continue

        t_c_a1 = get_Tolman_CA(alpha_dict, B)
        t_c_a2 = get_Tolman_CA_MAX(alpha_dict)
        # store molecule id and calculated cone angle
        TCA_dict['Molecule'].append(mol_name)
        TCA_dict['Tolman_Cone_Angle'].append(t_c_a1)
        TCA_dict['Max_Angle'].append(t_c_a2)
    return TCA_dict


# here is the input of folder path where Li-Nu.xyz files are stored
xyz_folder = r''
df = pd.DataFrame(execute_model(xyz_folder))
# set the output path here
df.to_excel(r'')
